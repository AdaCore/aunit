<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <meta http-equiv="CONTENT-TYPE"
 content="text/html; charset=iso-8859-1">
  <title></title>
  <meta name="GENERATOR" content="StarOffice/5.2 (Linux)">
  <meta name="AUTHOR" content=" ">
  <meta name="CREATED" content="20000320;9474300">
  <meta name="CHANGEDBY" content="Ed Falis">
  <meta name="CHANGED" content="20050512;15395100">
</head>
<body>
<h1><font color="#33ff33">A</font><font color="#cc0000">U</font>nit
Cookbook</h1>
<p
 style="border-style: none none double; border-color: -moz-use-text-color -moz-use-text-color rgb(128, 128, 128); border-width: medium medium 1.1pt; padding: 0in 0in 0.02in;">
<font style="font-size: 11pt;" size="2">Version 1.04</font></p>
<p><br>
This is a short guide for using the AUnit test framework.
AUnit is an adaptation of the Java JUnit (Kent Beck, Erich Gamma) unit
test framework for Ada code. This document is adapted from the JUnit
Cookbook document contained in the JUnit release package.</p>
<h2>Simple Test Case</h2>
<p>How do you write testing code? </p>
<p>The simplest way is as an expression in a debugger. You can change
debug expressions without recompiling, and you can wait to decide
what to write until you have seen the running objects. You can also
write test expressions as statements which print to the standard
output stream. Both styles of tests are limited because they require
human judgment to analyze their results. Also, they don't compose
nicely- you can only execute one debug expression at a time and a
program with too many print statements causes the dreaded "Scroll
Blindness". </p>
<p>AUnit tests do not require human judgment to interpret, and it is
easy to run many of them at the same time. When you need to test
something, here is what you do: </p>
<ol>
  <li>
    <p style="margin-bottom: 0in;">Declare a package for a test case -
a set of logically related test routines. A template for such a package
is in /AUnit/Template/pr_xxxx_xxx.ad*.&nbsp; GPS provides an <span
 style="font-style: italic;">Edit -&gt; Unit Testing </span>menu to
generate template code.<br>
    </p>
  </li>
  <li>
    <p style="margin-bottom: 0in;">Derive from <i><span style="">AUnit</span><b>.</b>Test_Cases.Test_Case</i>
in the new package. </p>
  </li>
  <li>
    <p style="margin-bottom: 0in;">The new derived type must provide
implementations of <i>Register_Tests</i> and <i>Name.</i></p>
  </li>
  <li>
    <p style="margin-bottom: 0in;">Write each test routine (see below)
and register it with a line in routine <i>Register_Tests</i>, of the
form:</p>
    <p style="margin-bottom: 0in;"><br>
    <font style="font-family: monospace;">Register_Routine (T,
Test_Name'Access, "Description of test routine");</font></p>
  </li>
  <li>
    <p>When you want to check a value, use:<br>
    <br>
    <font style="font-family: monospace;">AUnit.Assertions.</font><font
 style="font-family: monospace;">Assert</font><font
 style="font-family: monospace;">(Boolean_Expression,
String_Description);</font></p>
  </li>
  <li>
    <p>Create a suite function to gather together test cases and
sub-suites.&nbsp; Alternatively, you can call the <span
 style="font-style: italic;">Run</span> routine of a single test case
directly, and then call <span style="font-style: italic;">Test_Results.Test_Reporter.Report
    </span>on its <span style="font-style: italic;">Result</span>
parameter.&nbsp; This eliminates step 7.<br>
    </p>
  </li>
  <li>
    <p>At any level at which you wish to run tests, create a harness
instantiating Aunit.Test_Runner with a suite function collecting
together test cases and sub-suites to execute.</p>
  </li>
  <li>
    <p>AUnit includes a GNAT project file that should be included into
your application project to access the framework.&nbsp; For other
compilation systems, be sure to include the subdirectories of <span
 style="font-style: italic;">aunit</span> in your list of source
directories.<br>
    </p>
  </li>
  <li>
    <p align="left">Build the harness routine using gnatmake. <font
 size="3"><font face="Times New Roman, serif">The GNAT</font></font><font
 size="3"> project file</font><font size="3"><font
 face="Times New Roman, serif"> <span style="font-style: italic;">aunit-1.04/aunit_tests.gpr</span>
    </font></font><font size="3">contains all the necessary links and
switches for building test cases. When testing a new compiler, as
opposed to incremental unit tests, the GNAT "-f" switch should be set
for gnatmake. One can then use GNAT to build and run the tests.</font></p>
  </li>
</ol>
<p>For example, to test that the sum of two Moneys with the same
currency contains a value which is the sum of the values of the two
Moneys, the test routine would look like: </p>
<pre style="font-family: monospace;">procedure Test_Simple_Add<br>   (T : Aunit.Test_Cases.Test_Case'Class) is<br>   X, Y: Some_Currency;<br>begin<br>   X := 12; Y := 14;<br>   Assert (X + Y = 26, "Addition is incorrect");<br>end;</pre>
<p style="margin-bottom: 0in;">The package spec (taken almost directly
from pr_xxxx_xxx.ads) looks
as follows. The only modification was to remove support for a test
fixture (next section), and to provide a name for the unit. Changes
to "boilerplate code" are in bold:</p>
<p style="margin-bottom: 0in;"><br>
</p>
<p style="margin-bottom: 0in; font-family: monospace;">with
Ada.Strings.Unbounded;<br>
use
Ada.Strings.Unbounded;</p>
<p style="margin-bottom: 0in; font-family: monospace;">with
AUnit.Test_Cases;<br>
use
AUnit.Test_Cases;</p>
<p style="margin-bottom: 0in; font-family: monospace;">package
<b>PR_xxxx_xxx</b> is<br>
&nbsp;&nbsp; type
Test_Case is new AUnit.Test_Cases.Test_Case with
null record;</p>
<p style="margin-bottom: 0in; font-family: monospace;">&nbsp;&nbsp; --
Register routines to be run:<br>
&nbsp;&nbsp; procedure
Register_Tests (T: in out Test_Case);</p>
<p style="margin-bottom: 0in; font-family: monospace;">&nbsp;&nbsp; --
Provide name identifying the test case:<br>
&nbsp;&nbsp; function
Name (T: Test_Case) return String_Access;<br>
end
<b>PR_xxxx_xxx</b>;</p>
<p style="margin-bottom: 0in;"><br>
<font face="Times New Roman, serif"><font size="3">The
package body, constructed by modifying pr_xxxx_xxx.adb is:</font></font></p>
<p style="margin-bottom: 0in;"><br>
</p>
<pre style="font-family: monospace;">with AUnit.Test_Cases.Registration;<br>use AUnit.Test_Cases.Registration;<br><br>with AUnit.Assertions; use AUnit.Assertions;<br><br>-- Template for test case body.<br>package body <b>PR_xxxx_xxx</b> is<br><br><b>   -- Simple test routine:</b>
<b>   procedure Test_Simple_Add</b>
<b>      (T : Aunit.Test_Cases.Test_Case'Class) is</b>
<b>      X, Y: Some_Currency;</b>
<b>   begin</b>
<b>      X := 12; Y := 14;</b>
<b>      Assert </b>
<b>         (X + Y = 26, "Addition is incorrect");</b>
<b>   end;</b>

   -- Register test routines to call:
   procedure Register_Tests (T: access Test_Case) is
   begin
      -- Repeat for each test routine:
 <b>     Register_Routine (T, Test_Simple_Add'Access, "Test Addition");</b>
   end Register_Tests;



   -- Identifier of test case.  Just change the string
   -- result of the function.
   function Name (T: Test_Case) return String_Access is
   begin
      return new String'(<b>"Money Tests"</b>);<br>   end Name;<br><br>end <b>PR_xxxx_xxx</b>;</pre>
<p><font size="3">The corresponding harness code, adapted from
aunit-1.04/template/harness.adb is:</font></p>
<pre>with AUnit.Test_Cases; use AUnit.Test_Cases;<br>with AUnit.Test_Results.Test_Reporter; <br>use AUnit.Test_Results.Test_Reporter;<br><br>--  Test case to run:<br>with PR_XXXX_XXX;<br><br>procedure Harness is<br>   Test : PR_XXXX_XXX.Test_Case;<br>   Result : AUnit.Test_Results.Result;<br>begin<br>   Run (Test, Result);
   Report (Result);<br>end Harness;</pre>
<h2>Fixture</h2>
<p>Tests need to run against the background of a known set of
objects. This set of objects is called a test fixture. When you are
writing tests you will often find that you spend more time writing
the code to set up the fixture than you do in actually testing
values. </p>
<p>To some extent, you can make writing the fixture code easier by
paying careful attention to the constructors you write. However, a
much bigger savings comes from sharing fixture code. Often, you will
be able to use the same fixture for several different tests. Each
case will send slightly different messages or parameters to the
fixture and will check for different results. </p>
<p>When you have a common fixture, here is what you do: </p>
<ol>
  <li>
    <p style="margin-bottom: 0in;">Create a package as in the previous
section, starting from the templates pr_xxxx_xxx.ad*</p>
  </li>
  <li>
    <p style="margin-bottom: 0in;">Add fields for elements of the
fixture into the package body.<br>
    <br>
    </p>
  </li>
  <li>Override <i><font face="courier, monospace">Set_Up_Case </font></i>
to initialize the fixture for all test routines.<br>
  </li>
  <li>
    <p>Override <i><font face="courier, monospace">Set_Up</font></i>
to initialize the variables before the execution of each routine.<br>
    </p>
  </li>
  <li>
    <p>Override <font face="courier, monospace"><i>Tear_Down</i> </font>to
release any&nbsp; resources you allocated in <i>S<font
 face="courier, monospace">et_Up</font></i><font
 face="courier, monospace"> - to be executed after each test routine.<br>
    </font></p>
  </li>
  <li>Override <font face="courier, monospace"><i>Tear_Down_Case</i> </font>to
release any permanent resources you allocated in <i>S<font
 face="courier, monospace">et_Up_Case </font></i><font
 face="courier, monospace">- executed after all test routines.<br>
    </font></li>
</ol>
<p>For example, to write several test cases that want to work with
different combinations of 12 Euros, 14 Euros, and 26
US Dollars, first create a fixture. The package spec is now:</p>
<pre style="font-family: monospace;">with Ada.Strings.Unbounded;<br>use Ada.Strings.Unbounded;<br><br>with AUnit.Test_Cases;<br>use AUnit.Test_Cases;<br>package PR_xxxx_xxx is<br>   type Test_Case is new AUnit.Test_Cases.Test_Case with null record;<br><br>    -- Register routines to be run:<br>   procedure Register_Tests (T: in out Test_Case);<br><br>   -- Provide name identifying the test case:<br>   function Name (T: Test_Case) return String_Access;<br><br><br><b>   -- Preparation performed before each routine:</b>
<b>   Procedure Set_Up (T: in out Test_Case);</b>

end PR_xxxx_xxx;</pre>
<p>The body becomes:</p>
<pre style="font-family: monospace;">with AUnit.Test_Cases.Registration;<br>use AUnit.Test_Cases.Registration;<br><br>with AUnit.Assertions; use AUnit.Assertions;<br><br><b>with Currencies; use Currencies;</b><br>package body PR_xxxx_xxx is<br>   <b>-- Fixture elements:</b><br>  <b> EU_12, EU_14: Euro; </b><br><b>   US_26: US_Dollar;</b><br><br>   <b>-- Preparation performed before each routine:</b><br><b>   Procedure Set_Up (T: in out Test_Case) is</b><br><b>   begin</b><br><b>      EU_12 := 12; EU_14 := 14;</b><br><b>      US_26 := 26;</b><br><b>   end Set_Up;</b><br><br>   -- Simple test routine:<br>   procedure Test_Simple_Add<br>     (T : Aunit.Test_Cases.Test_Case'Class) is<br>   begin<br><b>       Assert </b><br><b>        (EU_12 + EU_14 /= US_26, </b><br><b>         "US and EU currencies not differentiated");</b><br><b> </b>  end;<br><br>   -- Register test routines to call:<br>   procedure Register_Tests (T: in out Test_Case) is<br>   begin<br>      -- Repeat for each test routine:<br>      Register_Routine (T, Test_Simple_Add'Access, "Test Addition");<br>   end Register_Tests;<br><br><br><br>   -- Identifier of test case.  Just change the string<br>   -- result of the function.<br>   function Name (T: Test_Case) return String_Access is<br>   begin<br>      return  new String'("Money Tests");<br>   end Name;<br><br>end PR_xxxx_xxx;</pre>
<p>Once you have the fixture in place, you can write as many test
routines as you like. Calls to <font face="courier, monospace">Set_Up</font>
and <font face="courier, monospace">Tear_Down</font>
bracket the invocation of
each test routine.</p>
<p>Note that as of AUnit 1.01 a
parameter of type AUnit.Test_Cases.Test_Case'Class has been added to
test routines. This parameter allows access to the current Test_Case
instance, so that a test routine can access per-instance (rather than
package body global) data. This can be useful when part of the data to
be used depends on a particular test case instance, while another part
is global data of the test fixture.<br>
</p>
<p>Once you have several test cases, organize them into a Suite. </p>
<h2>Suite</h2>
<p>How do you run several test cases at once? </p>
<p>As soon as you have two tests, you'll want to run them together.
You could run the tests one at a time yourself, but you would quickly
grow tired of that. Instead, AUnit provides an object, <font
 face="courier, monospace">Test_Suite</font>
which runs any number of test cases together. </p>
<p>For test routines that use the same fixture (i.e. those declared
in the same package), the <font face="courier, monospace">Register_Routine</font>
procedure is used to
collect them into the single test case.</p>
<p>A single Test_Case and its
collection of routines can be executed directly in a harness like so:</p>
<pre style="margin-bottom: 0.2in; font-family: monospace;">...<br>Test : PR_XXXX_XXX.Test_Case;<br>Result : AUnit.Test_Results.Result;<br>...<br>Run (Test, Result);<br>Report (Result);<br></pre>
<p>To create a suite of two test cases and run them together, execute: </p>
<pre style="font-family: monospace;">with AUnit.Test_Suites; use AUnit.Test_Suites;<br>with AUnit.Test_Runner;<br><br>--  List of tests and suites to run:<br>with Test_Case_1, Test_Case_2;<br><br>procedure Harness is<br><br><b>   function Suite return Access_Test_Suite is</b>
<b>      Result : Access_Test_Suite := new Test_Suite;</b>
<b>   begin</b>
<b>      --  You may add multiple tests or suites here:</b>
<b>      Add_Test (Result, new Test_Case_1.Test_Case);</b>
<b>      Add_Test (Result, new Test_Case_2.Test_Case);</b>
<b>      return Result;</b>
<b>   end Suite;</b>

   procedure Run is new AUnit.Test_Runner (Suite);

begin
   Run;
end Harness;</pre>
<h2 style="font-family: monospace;">Composition of Suites</h2>
<p style="font-family: monospace;">Typically, one will want the
flexibility to execute a complete set
of tests, or some subset of them. In order to facilitate this, we can
reorganize the harness so that the composition of test cases and
suites is done in a separate library function, and each composition
level can have its own harness:</p>
<pre style="font-family: monospace;">-- Composition function:<br>with AUnit.Test_Suites; use Aunit.Test_Suites;<br><br>-- List of tests and suites to compose:<br>with Test_Case_1;<br>with Test_Case_2;<br>function This_Suite return Access_Test_Suite is<br>   Result : Access_Test_Suite := new Test_Suite;<br>begin<br>   Add_Test (Result, new Test_Case_1.Test_Case);<br>   Add_Test (Result, new Test_Case_2.Test_Case);<br>   return Result;<br>end Suite;<br><br><br>-- More general form of harness for a given level:<br>with AUnit.Test_Runner;<br><br>--  Composition function for this level:<br>with This_Suite;<br><br>procedure Harness is<br>   procedure Run is new AUnit.Test_Runner (This_Suite);<br>begin<br>   Run;<br>end Harness;</pre>
<p>At a higher level, we may wish to combine two suites of units tests
that are composed with functions <font size="2"><font
 face="Courier, monospace">This_Suite</font></font>
and <font size="2"><font face="Courier, monospace">That_Suite</font></font>.</p>
<p>The corresponding composition function and harness would be:</p>
<pre>-- Composition function:<br>with AUnit.Test_Suites; use Aunit.Test_Suites;<br><br>-- List of tests and suites to compose:<br>with Suite_1;<br>with Suite_2;<br>function Composition_Suite return Access_Test_Suite is<br>   Result : Access_Test_Suite := new Test_Suite;<br>begin<br>   Add_Test (Result, Suite_1);<br>   Add_Test (Result, Suite_2);<br>   return Result;<br>end Composition_Suite;<br><br><br>-- More general form of harness for a given level:<br>with AUnit.Test_Runner;<br><br>--  Composition function for this level:<br>with Composition_Suite;<br><br>procedure Harness is<br>   procedure Run is new AUnit.Test_Runner (Composition_Suite);<br>begin<br>   Run;<br>end Harness;</pre>
<p style="">As can be seen, this is a very flexible way of composing
test cases
into execution runs.</p>
<p style="">Note that the Aunit.Test_Runner.Run
routine has a defaulted parameter to control whether timing
information is reported. Its speficiation is:</p>
<pre>procedure Run (Timed : Boolean := True);</pre>
<p style="margin-bottom: 0in;"><br>
By default the execution time for a
harness is reported. If you are running some number of harnesses
from a scripting language, and comparing the result to an existing
file, using <span style="font-style: normal;"><font size="2"><font
 face="Courier, sans-serif">Timed
=&gt; False</font></font></span> ensures that the output will be
identical across successful runs.</p>
<h2>Reporting</h2>
<p style="">Currently test results are reported
using a simple console reporting routine:</p>
<pre style="margin-bottom: 0.2in;">   Test_Results.Text_Reporter.Report (Result);</pre>
<p>A sample run on a set of problem reports submitted to ACT prints the
following to the console when executed:</p>
<pre>[efalis@dogen AUnit]$ ./harness<br>   Total Tests Run:  10<br><br>   Failed Tests: 1<br>      PR 7503-008.Allocation_Test:: Bad discriminant check<br><br>   Unexpected Errors: 0</pre>
<p>The switch "-v" may be used with any harness to cause the
list of successful tests to be printed along with any failures or
errors:</p>
<pre>[efalis@dogen AUnit]$ ./harness -v<br>   Total Tests Run:  17<br><br>   Successful Tests: 17<br>      PR 7112-001: Record_Initialization<br>      PR 7210-005: Test_1<br>      PR 7210-005: Test_2<br>      PR 7210-005: Test_3<br>      PR 7210-005: Test_4<br>      PR 7210-005: Test_5<br>      PR 7210-005: Test_6<br>      PR 7210-005: Test_A<br>      PR 7210-005: Test_B<br>      PR 7503-008: Allocation_Test<br>      PR 7605-009: Modular_Bounds<br>      PR 8010-001b: Test calculation of constant with modular sub-expression<br>      PR 7522-012: Subtype not recognized in initialization<br>      PR 7617-011: Test renaming in instantiation I<br>      PR 7624-003: Use of multi-dimensional aggregate as generic actual parameter<br>      PR 7813-010: Test -gnatc for bogus semantic error<br>      PR 8010-009: Overload resolution with enumeration literals<br><br>   Failed Tests: 0<br><br>   Unexpected Errors: 0<br><br>Time:  0.001011000 seconds<br><br></pre>
<h2>GPS Support</h2>
Note that the GPS IDE has a menu <span style="font-weight: bold;"><span
 style="font-style: italic;">Edit -&gt; Unit Testing</span></span> to
generate the template code for test cases, test suites and harnesses.<br>
<br>
<pre><br></pre>
</body>
</html>
